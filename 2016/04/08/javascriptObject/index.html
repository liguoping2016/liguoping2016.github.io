<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <meta name="renderer" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=edge" >
  <link rel="dns-prefetch" href="http://yoursite.com">
  <title>javascriptObject | 前端小博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="JavaScript面向对象核心知识归纳面向对象概念
1.面向对象就是使用对象。面向对象开发就是使用对象开发。
2.面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

三大特性抽象性所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

1.提出需要的核心属性和方法
2.不在特定的环境下无法明确对象的具体意义

封装性对象是将数据与功能组合到一起，即封装

1.JS">
<meta property="og:type" content="article">
<meta property="og:title" content="javascriptObject">
<meta property="og:url" content="http://yoursite.com/2016/04/08/javascriptObject/index.html">
<meta property="og:site_name" content="前端小博客">
<meta property="og:description" content="JavaScript面向对象核心知识归纳面向对象概念
1.面向对象就是使用对象。面向对象开发就是使用对象开发。
2.面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

三大特性抽象性所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

1.提出需要的核心属性和方法
2.不在特定的环境下无法明确对象的具体意义

封装性对象是将数据与功能组合到一起，即封装

1.JS">
<meta property="og:image" content="https://segmentfault.com/img/remote/1460000007269207?w=652&h=439">
<meta property="og:updated_time" content="2016-11-19T01:27:06.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="javascriptObject">
<meta name="twitter:description" content="JavaScript面向对象核心知识归纳面向对象概念
1.面向对象就是使用对象。面向对象开发就是使用对象开发。
2.面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。

三大特性抽象性所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据

1.提出需要的核心属性和方法
2.不在特定的环境下无法明确对象的具体意义

封装性对象是将数据与功能组合到一起，即封装

1.JS">
<meta name="twitter:image" content="https://segmentfault.com/img/remote/1460000007269207?w=652&h=439">
  
    <link rel="alternative" href="/atom.xml" title="前端小博客" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  <link rel="stylesheet" href="/main.css">
  

</head>

<body>
  <div id="container">
    <div class="left-col">
      <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			
			<img src="http://img5.imgtn.bdimg.com/it/u=1999300046,1517656119&amp;fm=21&amp;gp=0.jpg" class="js-avatar">
			
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">lgp</a></h1>
		</hgroup>

		

		<nav class="header-menu">
			<ul>
			
				<li><a href="/">主页</a></li>
	        
				<li><a href="/tags/随笔">随笔</a></li>
	        
			</ul>
		</nav>
		<nav class="header-smart-menu">
	        
    		
    			
    			<a class="js-smart-menu" data-idx="0" href="javascript:void(0)">所有文章</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="1" href="javascript:void(0)">标签</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="2" href="javascript:void(0)">友链</a>
    			
    			
            
    			
    			<a class="js-smart-menu" data-idx="3" href="javascript:void(0)">关于我</a>
    			
    			
            
		</nav>
		<nav class="header-nav">
			<div class="social">
				
					<a class="github" target="_blank" href="#" title="github">github</a>
		        
					<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
		        
					<a class="rss" target="_blank" href="#" title="rss">rss</a>
		        
					<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
		        
			</div>
		</nav>
	</header>		
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<div class="slider-trigger"><i class="icon-list"></i></div>
  		<h1 class="header-author js-mobile-header hide">lgp</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				
					<img src="http://img5.imgtn.bdimg.com/it/u=1999300046,1517656119&amp;fm=21&amp;gp=0.jpg" class="js-avatar">
				
			</div>
			<hgroup>
			  <h1 class="header-author">lgp</h1>
			</hgroup>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="#" title="github">github</a>
			        
						<a class="weibo" target="_blank" href="#" title="weibo">weibo</a>
			        
						<a class="rss" target="_blank" href="#" title="rss">rss</a>
			        
						<a class="zhihu" target="_blank" href="#" title="zhihu">zhihu</a>
			        
				</div>
			</nav>
		</header>				
	</div>
</nav>

      <div class="body-wrap">
        <article id="post-javascriptObject" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      javascriptObject
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h1 id="JavaScript面向对象核心知识归纳"><a href="#JavaScript面向对象核心知识归纳" class="headerlink" title="JavaScript面向对象核心知识归纳"></a>JavaScript面向对象核心知识归纳</h1><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><ul>
<li>1.面向对象就是使用对象。面向对象开发就是使用对象开发。</li>
<li>2.面向过程就是用过程的方式进行开发。面向对象是对面向过程的封装。</li>
</ul>
<h3 id="三大特性"><a href="#三大特性" class="headerlink" title="三大特性"></a>三大特性</h3><h5 id="抽象性"><a href="#抽象性" class="headerlink" title="抽象性"></a>抽象性</h5><p>所谓的抽象性就是：如果需要一个对象描述数据，需要抽取这个对象的核心数据</p>
<ul>
<li>1.提出需要的核心属性和方法</li>
<li>2.不在特定的环境下无法明确对象的具体意义</li>
</ul>
<h5 id="封装性"><a href="#封装性" class="headerlink" title="封装性"></a>封装性</h5><p>对象是将数据与功能组合到一起，即封装</p>
<ul>
<li>1.JS对象就是键值对的集合，键值如果是数据（基本数据、符合数据、空数据）就称为属性，如果键值是函数那么就称为方法</li>
<li>2.对象就是将属性与方法封装起来</li>
<li>3.方法是将过程封装起来</li>
</ul>
<h5 id="继承性"><a href="#继承性" class="headerlink" title="继承性"></a>继承性</h5><p>所谓继承性就是自己没有但是别人有，拿过来成为自己的，就是继承，继承是实现复用的一种手段</p>
<ul>
<li>在Java等语言中继承满足一个class的规则，类是一个class，他规定了一个对象有什么属性和方法。</li>
<li>在这些语言中继承是class之间的继承，一个class继承另一个class，那么该class就有了另一个class的成员，那么由该class创建出来的对象就同时具有两个class的成员。</li>
</ul>
<p>在JS中没有明确的继承语法（ES6提供了class extend语法），一般都是按照继承的理念实现对象的成员扩充实现继承，因此JS中实现继承的方法非常对多。</p>
<p>传统继承基于类，JS继承基于对象</p>
<p>一个简单的继承模式：混入（mix）</p>
<pre><code>function mix ( o1, o2 ) {
    for ( var k in o2 ) {
        o1[ k ] = o2[ k ];
    }    
}
</code></pre><h3 id="关于面向对象的一些其他概念"><a href="#关于面向对象的一些其他概念" class="headerlink" title="关于面向对象的一些其他概念"></a>关于面向对象的一些其他概念</h3><h5 id="类class：在JS中就是构造函数"><a href="#类class：在JS中就是构造函数" class="headerlink" title="类class：在JS中就是构造函数"></a>类<code>class</code>：在<code>JS</code>中就是构造函数</h5><ul>
<li>在传统的面向对象语言中，使用一个叫类的东西定义模板，然后使用模板创建对象。</li>
<li>在构造方法中也具有类似的功能，因此也称其为类</li>
</ul>
<h5 id="实例-instance-与对象（object）"><a href="#实例-instance-与对象（object）" class="headerlink" title="实例(instance)与对象（object）"></a>实例(<code>instance</code>)与对象（<code>object</code>）</h5><ul>
<li>实例一般是指某一个构造函数创建出来的对象，我们称为XXXX 构造函数的实例</li>
<li>实例就是对象。对象是一个泛称</li>
<li>实例与对象是一个近义词</li>
</ul>
<h5 id="键值对与属性和方法"><a href="#键值对与属性和方法" class="headerlink" title="键值对与属性和方法"></a>键值对与属性和方法</h5><ul>
<li>在JS中键值对的集合称为对象</li>
<li>如果值为数据（非函数），就称该键值对为属性</li>
<li>如果值为函数（方法），就称该键值对为方法method</li>
<li><h5 id="父类与子类（基类和派生类）"><a href="#父类与子类（基类和派生类）" class="headerlink" title="父类与子类（基类和派生类）"></a>父类与子类（基类和派生类）</h5></li>
<li><p>传统的面向对象语言中使用类来实现继承那么就有父类、子类的概念</p>
</li>
<li>父类又称为基类，子类又称为派生类</li>
<li>在JS中没有类的概念，在JS中常常称为父对象，子对象，基对象，派生对象。</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><h4 id="构造函数是干什么用的"><a href="#构造函数是干什么用的" class="headerlink" title="构造函数是干什么用的"></a>构造函数是干什么用的</h4><ul>
<li>初始化数据的</li>
<li>在JS中给对象添加属性用的，初始化属性值用的</li>
</ul>
<h4 id="创建对象的过程"><a href="#创建对象的过程" class="headerlink" title="创建对象的过程"></a>创建对象的过程</h4><ul>
<li>1.代码：var p = new Person();</li>
<li>2.首先运算符new创建了一个对象，类似于{}，是一个没有任何（自定义）成员的对象。<ul>
<li>使用 new 创建对象，那么对象的类型就是创建他的构造函数名</li>
<li>使用{}无论如何都是Object类型，相当于 new Object</li>
</ul>
</li>
<li>3.然后调用构造函数，为其初始化成员<ul>
<li>构造函数在调用的一开始，有一个赋值操作，即this = 刚刚创建出来的对象。</li>
<li>因此在构造函数中this表示刚刚创建出来的对象。</li>
</ul>
</li>
<li>4.在构造函数中 利用 对象的动态特性 为其对象添加成员。</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><h4 id="什么是作用域"><a href="#什么是作用域" class="headerlink" title="什么是作用域"></a>什么是作用域</h4><p>域表示的就是范围，即作用域，就是一个名字在什么地方可以使用，什么时候不能使用。</p>
<h4 id="JS中词法作用域的规则"><a href="#JS中词法作用域的规则" class="headerlink" title="JS中词法作用域的规则"></a>JS中词法作用域的规则</h4><ul>
<li>1.函数允许访问函数外部的数据</li>
<li>整个代码结构中只有函数可以限定作用域</li>
<li>作用规则首先使用提升规则分析</li>
<li>如果当前作用域中有了名字了，就不考虑外面的名字</li>
</ul>
<h4 id="属性搜索原则"><a href="#属性搜索原则" class="headerlink" title="属性搜索原则"></a>属性搜索原则</h4><ul>
<li>所谓的属性搜索原则，就是对象在访问属性或方法的时候，首先在当前对象中查找</li>
<li>如果当前对象中存储着属性或方法，停止查找，直接使用该属性或方法</li>
<li>如果当前对象没有该成员，那么再在其原型对象中查找</li>
<li>如果原型对象中含有该成员，那么停止查找，直接使用</li>
<li>如果原型中还没有，就到原型的原型中查找</li>
<li>如此往复，直到Object.protitype还没有，那么就返回undefined</li>
<li>如果是调用方法就报错，该xxx不是一个函数</li>
</ul>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><h4 id="闭包的概念"><a href="#闭包的概念" class="headerlink" title="闭包的概念"></a>闭包的概念</h4><h5 id="什么是闭包？"><a href="#什么是闭包？" class="headerlink" title="什么是闭包？"></a>什么是闭包？</h5><p>闭包的含义就是闭合，包起来，简单的来说，就是一个具有封闭功能与包裹功能的结构。所谓的闭包就是一个具有封闭的对外不公开的，包裹结构，或空间。</p>
<h5 id="为什么函数可以构成闭包？"><a href="#为什么函数可以构成闭包？" class="headerlink" title="为什么函数可以构成闭包？"></a>为什么函数可以构成闭包？</h5><p>闭包就是一个具有封闭与包裹功能的结构，是为了实现具有私有访问空间的函数的。函数可以构成闭包。函数内部定义的数据函数外部无法访问，即函数具有封闭性；函数可以封装代码即具有包裹性，所以函数可以构成闭包。</p>
<h4 id="闭包有什么用"><a href="#闭包有什么用" class="headerlink" title="闭包有什么用"></a>闭包有什么用</h4><p>闭包不允许外部访问，要解决的问题就是让外部间接访问函数内部的数据。事实上，通过使用闭包，我们可以做很多事情。比如模拟面向对象的代码风格；更优雅，更简洁的表达出代码；在某些方面提升代码的执行效率。利用闭包可以实现如下需求：</p>
<ul>
<li>1.匿名自执行函数一个匿名的函数，并立即执行它，由于外部无法引用它内部的变量，因此在执行完后很快就会被释放，关键是这种机制不会污染全局对象。</li>
<li>2.缓存闭包正是可以做到这一点，因为它不会释放外部的引用，从而函数内部的值可以得以保留。</li>
<li>3.实现封装</li>
<li>4.模拟面向对象的代码风格</li>
</ul>
<h4 id="闭包的基本模型"><a href="#闭包的基本模型" class="headerlink" title="闭包的基本模型"></a>闭包的基本模型</h4><ul>
<li>1.对象模式函数内部定义个一个对象，对象中绑定多个函数（方法），返回对象，利用对象的方法访问函数内的数据</li>
<li>2.函数模式函数内部定义一个新函数，返回新函数，用新函数获得函数内的数据</li>
<li>3.沙箱模式沙箱模式就是一个自调用函数，代码写到函数中一样会执行，但是不会与外界有任何的影响</li>
</ul>
<h4 id="闭包的作用举例"><a href="#闭包的作用举例" class="headerlink" title="闭包的作用举例"></a>闭包的作用举例</h4><ul>
<li>1.获得超过一个数据，返回一个对象</li>
<li>2.完成读取一个数据和修改这个数据，对象里面的getset方法</li>
</ul>
<h4 id="闭包的性能问题"><a href="#闭包的性能问题" class="headerlink" title="闭包的性能问题"></a>闭包的性能问题</h4><p>函数执行需要内存，那么函数中定义的变量，会在函数执行结束后自动回收，凡是因为闭包结构的，被引出的数据，如果还有变量引用这些数据的话，那么这些数据就不会被回收。因此在使用闭包的时候如果不使用某些数据了，一定要赋值一个null</p>
<pre><code>var f = (function () {
    var num = 123;
    return function () {
        return num;
    };
})();
// f 引用着函数，函数引用着变量num
// 因此在不使用该数据的时候，最好写上
f = null;
</code></pre><h3 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h3><h4 id="什么是原型"><a href="#什么是原型" class="headerlink" title="什么是原型"></a>什么是原型</h4><p>一句话说明什么是原型：原型能存储我们的方法，构造函数创建出来的实例对象能够引用原型中的方法。</p>
<p>JS中一切皆对象，而每个对象都有一个原型（Object除外），这个原型，大概就像Java中的父类，所以，基本上你可以认为原型就是这个对象的父对象，即每一个对象（Object除外）内部都保存了它自己的父对象，这个父对象就是原型。一般创建的对象如果没有特别指定原型，那么它的原型就是Object(这就很类似Java中所有的类默认继承自Object类)。</p>
<p>ES6通过引入class ,extends等关键字，以一种语法糖的形式把构造函数包装成类的概念，更便于大家理解。是希望开发者不再花精力去关注原型以及原型链，也充分说明原型的设计意图和类是一样的。</p>
<h4 id="查看对象的原型"><a href="#查看对象的原型" class="headerlink" title="查看对象的原型"></a>查看对象的原型</h4><p>当对象被创建之后，查看它们的原型的方法不止一种，以前一般使用对象的<strong>proto</strong>属性，ES6推出后，推荐用 Object.getPrototypeOf()方法来获取对象的原型.</p>
<pre><code>function A(){
    this.name=&apos;lala&apos;;
}
var a=new A();
console.log(a.__proto__) 
//输出：Object {}

//推荐使用这种方式获取对象的原型
console.log(Object.getPrototypeOf(a)) 
//输出：Object {}
</code></pre><p>无论对象是如何创建的，默认原型都是Object，在这里需要提及的比较特殊的一点就是，通过构造函数来创建对象，函数A本身也是一个对象，而A有两个指向表示原型的属性，分别是proto和prototype，而且两个属性并不相同</p>
<pre><code>function A(){
       this.name=&apos;lala&apos;;
}
var a=new A();
console.log(A.prototype) 
//输出：Object {}

console.log(A.__proto__) 
//输出：function () {}
console.log(Object.getPrototypeOf(A))
//输出：function () {}
</code></pre><p>函数的的prototype属性只有在当作构造函数创建的时候，把自身的prototype属性值赋给对象的原型。而实际上，作为函数本身，它的原型应该是function对象，然后function对象的原型才是Object。</p>
<p>总之，建议使用<code>ES6</code>推荐的查看原型和设置原型的方法。</p>
<h3 id="原型的用法"><a href="#原型的用法" class="headerlink" title="原型的用法"></a>原型的用法</h3><p>其实原型和类的继承的用法是一致的：当你想用某个对象的属性时，将当前对象的原型指向该对象，你就拥有了该对象的使用权了。</p>
<pre><code>function A(){
    this.name=&apos;world &apos;;
}
function B(){
    this.bb=&quot;hello&quot;
}
var a=new A();
var b=new B();

//将b设置为a的原型,此处有一个问题，即a的constructor也指向了B构造函数，可能需要纠正 
Object.setPrototypeOf(a,b);
a.constructor=A;
console.log(a.bb);    //hello
</code></pre><p>如果使用ES6来做的话则简单许多，甚至不涉及到prototype这个属性</p>
<pre><code>class B{
     constructor(){
        this.bb=&apos;hello&apos;
     }
}
class A  extends B{
     constructor(){
        super();
        this.name=&apos;world&apos;;
     }
}

var a=new A();
console.log(a.bb+&quot; &quot;+a.name);    //hello world
console.log(typeof(A))                //&quot;function&quot;
</code></pre><p>怎么样？是不是已经完全看不到原型的影子了？活脱脱就是类继承，但是你也看得到实际上类A 的类型是function，所以说，本质上class在JS中是一种语法糖，JS继承的本质依然是原型，不过，ES6引入class，extends 来掩盖原型的概念也是一个很友好的举动，对于长期学习那些类继承为基础的面对对象编程语言的程序员而言。</p>
<p>我的建议是，尽可能理解原型，尽可能用class这种语法糖。</p>
<p>好了，问自己两个问题：</p>
<ul>
<li>1.为什么要使用原型？——提高函数的复用性。</li>
<li><p>2.为什么属性不放在原型上而方法要放在原型上？</p>
<ul>
<li>利用对象的动态特性：构造函数.prototype.xxxx = vvv</li>
<li><p>利用直接替换</p>
<p>Student.prototype = {<br>  sayHello : function(){},<br>  study : function(){}<br>};</p>
</li>
</ul>
</li>
</ul>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><h5 id="什么是原型链？"><a href="#什么是原型链？" class="headerlink" title="什么是原型链？"></a>什么是原型链？</h5><p>凡是对象就有原型，那么原型又是对象，因此凡是给定一个对象，那么就可以找到他的原型，原型还有原型，那么如此下去，就构成一个对象的序列，称该结构为原型链。</p>
<p>这个概念其实也变得比较简单，可以类比类的继承链条，即每个对象的原型往上追溯，一直到Object为止，这组成了一个链条，将其中的对象串联起来，当查找当前对象的属性时，如果没找到，就会沿着这个链条去查找，一直到Object，如果还没发现，就会报undefined。</p>
<h5 id="原型链的结构"><a href="#原型链的结构" class="headerlink" title="原型链的结构"></a>原型链的结构</h5><p>凡是使用构造函数，创建出对象，并且没有利用赋值的方式修改原型，就说该对象保留默认的原型链。<br>默认原型链结构是什么样子呢？</p>
<pre><code>function Person(){}
var p = new Person();
//p 具有默认的原型链
</code></pre><p>默认的原型链结构就是：<code>当前对象 -&gt; 构造函数.prototype -&gt; Object.prototype -&gt; null</code></p>
<p>在实现继承的时候，有时候会利用替换原型链结构的方式实现原型继承，那么原型链结构就会发生改变</p>
<pre><code>function DunizbCollection(){}
DunizbCollection.prototype = [];
var arr = new DunizbCollection();
</code></pre><p>此时arr对象的原型链结构被指向了数组对象的原型链结构了：<code>arr -&gt; [] -&gt; Array.prototype -&gt; Object.prototype -&gt; null</code></p>
<h5 id="用图形表示对象的原型链结构"><a href="#用图形表示对象的原型链结构" class="headerlink" title="用图形表示对象的原型链结构"></a>用图形表示对象的原型链结构</h5><p>以如下代码为例绘制原型链结构</p>
<pre><code>function Person(){}
var p = new Person();
</code></pre><p>原型链结构图为：<br><img src="https://segmentfault.com/img/remote/1460000007269207?w=652&amp;h=439" alt=""><br>使用原型需要注意两点：</p>
<ul>
<li>1.原型继承链条不要太长，否则会出现效率问题。</li>
<li>2.指定原型时，注意constructor也会改变。<h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5>实现继承有两种常见方式：</li>
</ul>
<p><code>混合式继承</code>：最简单的继承就是将别的对象的属性强加到我身上，那么我就有这个成员了。<br>混合式继承的简单描述：</p>
<pre><code>var Person = function () {};
Person.prototype.extend = function ( o ) {
     for ( var k in o ) {
          this[ k ] = o[ k ];
     }
};
Person.prototype.extend({
      run: function () { console.log( &apos;我能跑了&apos; ); },
      eat: function () { console.log( &apos;我可以吃了&apos; ); },
      sayHello: function () { console.log( &apos;我吃饱    了&apos; ); }
});
</code></pre><p><code>原型继承</code>：利用原型也可以实现继承，不需要在我身上添加任何成员，只要原型有了我就有了。</p>
<h5 id="借用构造函数继承"><a href="#借用构造函数继承" class="headerlink" title="借用构造函数继承"></a>借用构造函数继承</h5><p>这种技术的基本思想相当简单，即在子类型构造函数的内部调用超类型构造函数，而函数只不过是在特定环境中执行代码的对象，因此通过使用apply()和call()方法也可以在（将来）新创建的对象上执行构造函数</p>
<pre><code>function Person ( name, age, gender ) {
    this.name = name;
    this.age = age;
    this.gender = gender;
}
// 需要提供一个 Student 的构造函数创建学生对象
// 学生也应该有 name, age, gender, 同时还需要有 course 课程
function Student ( name, age, gender, course ) {
    Person.call( this, name, age, gender )；
    this.course = course;
}
</code></pre><p>在《<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript" target="_blank" rel="external">JavaScript</a>高级程序设计（第三版）》中详细介绍了继承的6种方式</p>
<h3 id="函数的四种调用模式"><a href="#函数的四种调用模式" class="headerlink" title="函数的四种调用模式"></a>函数的四种调用模式</h3><h4 id="函数模式"><a href="#函数模式" class="headerlink" title="函数模式"></a>函数模式</h4><p>就是一个简单的函数调用。函数名的前面没有任何引导内容。</p>
<h4 id="方法模式"><a href="#方法模式" class="headerlink" title="方法模式"></a>方法模式</h4><p>方法一定式依附与一个对象，将函数赋值给对象的一个属性，那么就成为了方法。</p>
<h4 id="构造器调用模式"><a href="#构造器调用模式" class="headerlink" title="构造器调用模式"></a>构造器调用模式</h4><p>创建对象的时候构造函数做了什么？由于构造函数只是给 this 添加成员，没有做其他事情。而方法也可以完成这个操作，就是 this 而言，构造函数与方法没有本质的区别。</p>
<p><code>特征</code></p>
<ul>
<li>1.使用 new 关键字，来引导构造函数。</li>
<li>2.构造函数中的 this 与方法中的一样，表示对象，但是构造函数中的对象是刚刚创建出来的对象<ul>
<li>3.构造函数中不需要 return ，就会默认的 return this。</li>
<li>如果手动添加return ，就相当于 return this</li>
<li>如果手动的添加 return 基本类型，无效，还是保留原来 返回 this</li>
<li>如果手动添加的 return null，或 return undefined ，无效</li>
<li>如果手动添加 return 对象类型，那么原来创建的 this 就会被丢掉，返回的是 return 后面的对象</li>
</ul>
</li>
</ul>
<h5 id="创建对象的模式"><a href="#创建对象的模式" class="headerlink" title="创建对象的模式"></a>创建对象的模式</h5><ul>
<li>1.工厂方法，工厂就是用来生产的，因此如果函数创建对象并返回，就称该函数为工厂函数</li>
<li>2.构造方法</li>
<li>3.寄生式创建</li>
<li>4.混合式创建</li>
</ul>
<h4 id="上下文调用模式"><a href="#上下文调用模式" class="headerlink" title="上下文调用模式"></a>上下文调用模式</h4><p>上下文就是环境。就是自己定义设置 this 的含义。</p>
<p><code>语法</code></p>
<ul>
<li>函数名.apply( 对象, [ 参数 ] );</li>
<li>函数名.call( 对象, 参数 );</li>
</ul>
<p><code>描述</code></p>
<ul>
<li>1.函数名就是表示函数本身，使用函数进行调用的时候默认 this 是全局变量</li>
<li>2.函数名也可以是方法提供，使用方法调用的时候，this 是指向当前对象</li>
<li>3.使用 apply 进行调用后，无论是函数还是方法都无效了，我们的 this ，由 apply 的第一个参数决定</li>
</ul>
<p><code>参数问题</code></p>
<p>无论是 call 还是 apply 在没有后面的参数的情况下（函数无参数，方法五参数）是完全一致的</p>
<pre><code>function foo(){
    console.log( this );
}
foo.apply( obj );
foo.call( obj );
</code></pre><p>第一个参数的使用也是有规则的:</p>
<ul>
<li>1.如果传入的是一个对象，那么就相当于设置该函数中的 this 为参数</li>
<li><p>2.如果不传入参数，或传入 null 、undefined 等，那么相当于 this 默认为 window</p>
<pre><code>foo();
foo.apply();
foo.apply( null );
foo.call( undefined );
</code></pre></li>
<li><p>3.如果传入的是基本类型，那么 this 就是基本类型对应的包装类型的引用<br>在使用上下文调用的时候，原函数（方法）可能会带有参数，那么这个参数再上下文调用中使用 第二个（第 n 个）参数来表示</p>
<pre><code>function foo( num ) {
    console.log( num );
}
foo.apply( null, [ 123 ] );
// 等价于
foo( 123 );
</code></pre><p>参考资料</p>
</li>
<li>本文原型部分部分引用自<a href="http://www.admin10000.com/document/9336.html" target="_blank" rel="external">《JavaScript原型详解》</a>，版权归原作者所有</li>
<li><a href="http://blog.csdn.net/sunlylorn/article/details/6534610" target="_blank" rel="external">js闭包的用途</a></li>
</ul>
<p>摘自：<a href="http://www.imooc.com/u/173711/articles" target="_blank" rel="external">慕课网</a></p>

      
    </div>
    <div class="article-info article-info-index">
      
      <a href="/2016/04/08/javascriptObject/" class="archive-article-date">
  	<time datetime="2016-04-08T01:26:24.000Z" itemprop="datePublished"><i class="icon-clock"></i>2016-04-08</time>
</a>
      
      

      <div class="clearfix"></div>
    </div>
  </div>
</article>

  
<nav id="article-nav">
  
    <a href="/2016/05/24/flex/" id="article-nav-newer" class="article-nav-link-wrap">
      <i class="icon-circle-left"></i>
      <div class="article-nav-title">
        
          flex
        
      </div>
    </a>
  
  
    <a href="/2016/03/07/about-javascript-gif/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">javascript gif</div>
      <i class="icon-circle-right"></i>
    </a>
  
</nav>




<div class="share_jia">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">Share to: &nbsp; </span>
		<a class="jiathis_button_facebook"></a> 
	    <a class="jiathis_button_twitter"></a>
	    <a class="jiathis_button_plus"></a> 
	    <a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
    <a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="//v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>






<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="javascriptObject" data-title="javascriptObject" data-url="http://yoursite.com/2016/04/08/javascriptObject/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>





      </div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 lgp
    	</div>
      	<div class="footer-right">
      		<a href="http://hexo.io/" target="_blank">Hexo</a>  Theme <a href="https://github.com/litten/hexo-theme-yilia" target="_blank">Yilia</a> by Litten
      	</div>
    </div>
  </div>
</footer>
    </div>
    <script>
	var yiliaConfig = {
		fancybox: true,
		mathjax: false,
		animate: true,
		isHome: false,
		isPost: true,
		isArchive: false,
		isTag: false,
		isCategory: false,
		open_in_new: false,
		root: "/",
		innerArchive: true
	}
</script>

<script src="/./main.js"></script>


    
<div class="tools-col">
  <ul class="btn-wrap">
    
      <li class="chose" data-hook="tools-section-all"><span class="text">全部</span><i class="icon-book"></i></li>
    
    
      <li data-hook="tools-section-tag"><span class="text">标签</span><i class="icon-price-tags"></i></li>
    
    
      <li data-hook="tools-section-friends"><span class="text">友链</span><i class="icon-link"></i></li>
    
    
      <li data-hook="tools-section-me"><span class="text">我</span><i class="icon-smile"></i></li>
    
  </ul>
  <div class="tools-wrap">
    
    	<section class="tools-section tools-section-all chose">
    	</section>
    

    
    	<section class="tools-section tools-section-tag">
    			<div class="widget tagcloud" id="js-tagcloud">
    				
    			</div>
    	</section>
    

    
    	<section class="tools-section tools-section-friends">
  		
  			<div class="friends-wrap" id="js-friends">
  			
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接1</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接2</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接3</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接4</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接5</a>
  	        
  	          <a target="_blank" class="main-nav-link switch-friends-link" href="http://localhost:4000/">友情链接6</a>
  	        
  	        </div>
  		
    	</section>
    

    
    	<section class="tools-section tools-section-me">
  	  	
  	  		<div class="aboutme-wrap" id="js-aboutme">很惭愧&lt;br&gt;&lt;br&gt;只做了一点微小的工作&lt;br&gt;谢谢大家</div>
  	  	
    	</section>
    
  </div>
  
</div>
    <!-- Root element of PhotoSwipe. Must have class pswp. -->
<div class="pswp" tabindex="-1" role="dialog" aria-hidden="true">

    <!-- Background of PhotoSwipe. 
         It's a separate element as animating opacity is faster than rgba(). -->
    <div class="pswp__bg"></div>

    <!-- Slides wrapper with overflow:hidden. -->
    <div class="pswp__scroll-wrap">

        <!-- Container that holds slides. 
            PhotoSwipe keeps only 3 of them in the DOM to save memory.
            Don't modify these 3 pswp__item elements, data is added later on. -->
        <div class="pswp__container">
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
            <div class="pswp__item"></div>
        </div>

        <!-- Default (PhotoSwipeUI_Default) interface on top of sliding area. Can be changed. -->
        <div class="pswp__ui pswp__ui--hidden">

            <div class="pswp__top-bar">

                <!--  Controls are self-explanatory. Order can be changed. -->

                <div class="pswp__counter"></div>

                <button class="pswp__button pswp__button--close" title="Close (Esc)"></button>

                <button class="pswp__button pswp__button--share" style="display:none" title="Share"></button>

                <button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>

                <button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button>

                <!-- Preloader demo http://codepen.io/dimsemenov/pen/yyBWoR -->
                <!-- element will get class pswp__preloader--active when preloader is running -->
                <div class="pswp__preloader">
                    <div class="pswp__preloader__icn">
                      <div class="pswp__preloader__cut">
                        <div class="pswp__preloader__donut"></div>
                      </div>
                    </div>
                </div>
            </div>

            <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap">
                <div class="pswp__share-tooltip"></div> 
            </div>

            <button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)">
            </button>

            <button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)">
            </button>

            <div class="pswp__caption">
                <div class="pswp__caption__center"></div>
            </div>

        </div>

    </div>

</div>
  </div>
</body>
</html>